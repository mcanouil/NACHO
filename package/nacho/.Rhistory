#' independent of technical variation.
#' @param rcc_content List of dataframes originating from RCC files
#' @param pos_fact Positive normalization factor
#' @param intercept background threshold
#' @param custom String of concatenated housekeeping genes.
#' @return Vector transformed housekeeping gene counts.
#' @keywords internal
housekeeping <- function(rcc_content, pos_fact, intercept, custom){
counts <- rcc_content$Code_Summary
if(custom == ""){
house <- as.numeric(counts[counts$CodeClass %in%
"Housekeeping","Count"])
name <- counts[counts$CodeClass %in%
"Housekeeping","Name"]
}else{
custom <- unlist(strsplit(custom,"@"))
custom <- unlist(lapply(custom, function(x) unlist(strsplit(x,"\\|"))[1]))
house <- sapply(custom, function(x) as.numeric(counts[grepl(x, counts$Name),"Count"]))
}
house <- house - intercept
house <- house * pos_fact
house[house <= 0] <- 1
return(house)
}
#' @title Imaging QC
#' @description Calculates percentage succesfully counted image sections.
#' @param fov.counted succesfully counted image sections.
#' @param fov.count attempted counted image sections.
#' @return Percentage succesfully counted image sections.
#' @keywords internal
imaging.qc <- function(fov.counted, fov.count){
fov = (fov.counted / fov.count) * 100
return(round(fov,2))
}
#' @title Positive Control Linearity QC
#' @description  Calculates pearsons correlation coefficient of
#' positive control gene expression versus concentrations.
#' @param pos.counts Vector of measured positive control gene expression.
#' @return Correlation coefficient
#' @keywords internal
positive.control.qc <- function(pos.counts){
known <- log2(c(128,32,8,2,0.5))
measured <- log2(pos.counts[1:5])
correlation <- cor.test(known, measured)
return(unname(round(correlation$estimate,5)))
}
#' @title Limit of Detection QC
#' @description Calculates distance of POS_E expression from mean of
#'  negative control gene expressoins in term of standard deviations.
#' @param pos.e Expression of positive control gene "POS_E"
#' @param negatives Vector of negative control gene expressoins.
#' @return z-score
#' @keywords internal
limit.detection.qc <- function(pos.e, negatives){
z_score <- pos.e - mean(negatives) / sd(negatives)
return(round(z_score,2))
}
#' @title Prinicipal components
#' @description Calculates and returns principal components of a given
#' dataframe.
#' @param counts dataframe of nanoString counts
#' @return list containing a dataframe the first 10 principal components
#' and summary
#' @keywords internal
prinicipal_components <- function(counts){
pc <- prcomp(log(counts+1))
pc_sum <- summary(pc)
pc <- pc$rotation[,1:10]
output <- list("pc" = pc,
"pcsum" = pc_sum$importance[,1:10])
return(output)
}
#' @title Geometric mean
#' @description Calculates and returns geometric mean of a given vector.
#' @param vector_data numeric vector
#' @return geometric mean
#' @keywords internal
geoMean <- function(vector_data){
exp(mean(log(vector_data)))
}
#' @title Extracts counts of control probes and calculates the geometric mean.
#' @description Extracts counts of control probes and calculates the
#' geometric mean. Excludes positive control probe F in calculation.
#' @param rcc_content List of dataframes originating from RCC files
#' @param probes String of either "Positve" or "Negative"
#' @return geometric mean of control probes
#' @keywords internal
geometric <- function(rcc_content, probes){
counts <- rcc_content$Code_Summary
if(probes == "Positive"){
control_data <- as.numeric(counts[counts$CodeClass %in%
probes & counts$Name !=
"POS_F(0.125)","Count"])
control_data[control_data == 0] <- 1
}else if(probes == "Negative"){
control_data <- as.numeric(counts[counts$CodeClass %in%
probes,"Count"])
control_data[control_data == 0] <- 1
}
return(geoMean(control_data))
}
#' @title Calculates the background threshold and positive normalization
#' factor by means of generalized linear models.
#' @description Calculates the background threshold and positive normalization
#' factor by means of generalized linear models. Uses the intercept of the model
#' as background threshold and the slope as positive normalization factor,
#' excludes positive control probe F.
#' @param rcc_content List of dataframes originating from RCC files
#' @return Vector with positive factor and backrground threshold
#' @keywords internal
intercept_slope <- function(rcc_content,exc_negs){
probes_out <- c("POS_F(0.125)",exc_negs)
counts <- rcc_content$Code_Summary
control_labels <- c("Positive","Negative")
control_data <- counts[counts$CodeClass %in% control_labels,]
control_data <- control_data[order(control_data$Name),]
control_data <- control_data[!control_data$Name %in% probes_out,]
prob_names <- paste0(control_data$Name,collapse = "")
y <- as.numeric(control_data$Count) + 1
x <- as.numeric(gsub("[\\(\\)]", "", regmatches(prob_names,
gregexpr("\\(.*?\\)", prob_names))[[1]]))
model <- glm(y~x, family = poisson(link = identity))
output <- c("intercept" = unname(model$coeff[1]),
"slope" = unname(model$coeff[2]))
return(output)
}
#' @title Factor Calculation
#' @description Calculates normalization factors
#' @param rcc_content List of dataframes originating from RCC files
#' @param housekeep String of names of housekeeping genes
#' @param norm A string indicating which form of calculation needs to be performed
#' @return Dataframe of normalization factor for each sample
#' @keywords internal
factor_calculation <- function(rcc_content, housekeep, norm, ex_negs){
if(norm == "GEO"){
geometric_mean_pos <- sapply(rcc_content, geometric, "Positive")
geometric_mean_neg <- sapply(rcc_content, geometric, "Negative")
positive_factor <- sapply(geometric_mean_pos,
function(x) mean(geometric_mean_pos) / x)
}else if(norm == "GLM"){
glms <- sapply(rcc_content, intercept_slope, ex_negs)
geometric_mean_neg <- glms["intercept",]
slopes <- glms["slope",]
positive_factor <- sapply(slopes,
function(x) mean(slopes) / x)
}
if(housekeep == "predict"){
norm_factor <- data.frame("Positive_factor" = positive_factor,
"Negative_factor" = geometric_mean_neg)
}else{
housecounts <- mapply(housekeeping,rcc_content, positive_factor,
geometric_mean_neg, housekeep)
housecounts <- as.data.frame(housecounts)
geometric_mean_house <- sapply(housecounts,
function(x) geoMean(x))
house_factor <- sapply(geometric_mean_house,
function(x) mean(geometric_mean_house) / x)
house_factor <- unname(house_factor)
norm_factor <- data.frame("Positive_factor" = positive_factor,
"Negative_factor" = geometric_mean_neg,
"House_factor" = house_factor)
}
return(norm_factor)
}
#' @title Predict housekeeping genes
#' @description Predicts which genes could serve as housekeeping genes
#' @param counts dataframe of nanoString counts
#' @return vector of 5 possible housekeeping genes
#' @keywords internal
predict.housekeeping <- function(counts){
sample_means <- sapply(colnames(counts), function(x) mean(counts[,x]))
ratios <- sapply(colnames(counts), function(x) log2(counts[,x] / sample_means[x]))
ratios <- ratios[sum(is.infinite(ratios)) / length(ratios) <= 0.05,]
ratios <- ifelse(is.infinite(ratios),NA,ratios)
miR_sd <- sapply(rownames(ratios), function(x) sd(ratios[x,],na.rm = TRUE))
miR_sd <- sort(miR_sd, decreasing = F)
return(names(miR_sd)[1:5])
}
#' @title Probe exclusion
#' @description Compares probe specfic median with overal median, excludes probes when
#' probe specific mean differs more than 50% from overal median
#' @param control_genes dataframe of all control genes
#' @return names of excluded probes
#' @keywords internal
probe.exclusion <- function(control_genes){
local_neg <- control_genes[control_genes$CodeClass == "Negative",]
dcasted<- dcast(L1~Name, data = local_neg[,c("Name","L1","Count")], value.var = "Count")
rownames(dcasted) <- dcasted$L1
dcasted$L1 <- NULL
overal_median <- median(as.numeric(local_neg$Count))
medians <- sapply(dcasted,function(x) median(as.numeric(x)))
delta_medians <- sapply(medians,function(x) abs((overal_median-x)))
ex_probes <- delta_medians[delta_medians > (0.5*overal_median)]
return(names(ex_probes))
}
#' @title Summarize
#' @description Analyzes, calculates and summarizes nanoString nCounter RCC
#' files. The RCC files can be visually inspected through the summary when given as
#' input to the visualize function.
#' @param ssheet Path to a samplesheet containing at least a column with the
#' exact names of the RCC files which ought to be analyzed / summarized.
#' @param id_colname Refers to the name of the column containing exact names
#' of the RCC files which ought to be analyzed / summarized.
#' @param housekeep Vector with the names of the housekeeping genes. When no input is given,
#' the default housekeeping genes are used. When housekeep="predict" is used, the data will be
#' analyzed and the 5 best genes which could serve as housekeeping genes are used.
#' @param norm A string indicating which form of calculation needs to be performed:
#' "GEO" or "GLM"
#' @return A list containing the QC metrics,the original samplesheet,principal components,
#' normalization factors, control genes and counts.
#' @references
#' @examples
#' summarize("path/to/samplesheet.csv","FILE_COL","predict","GEO")
#' summarize("path/to/samplesheet.csv","FILE_COL","","GLM")
#' summarize("path/to/samplesheet.csv","FILE_COL,c("hsa-miR-361-5p","hsa-miR-186-5p","hsa-miR-26a-5p"),"GLM")
#' @export
summarize <- function(data_dir = NULL, ssheet=NULL,id_colname=NULL, housekeep="", norm="GEO"){
require(reshape2)
locations <- list.files(data_dir, pattern=".RCC",recursive = T)
housekeep <- paste(housekeep,collapse = "@")
ssheet_df <- load.samplesheet(ssheet)
accession <- ssheet_df[,id_colname]
location_match <- sapply(accession, function(y) locations[grep(y,locations)])
names(location_match) <- accession
location_match <- Filter(length,location_match)
accession <- names(location_match)
if(length(locations) > length(accession)){
warning("djdjdjd")
}
path_to_files <- paste(data_dir,location_match[accession],sep="/")
rcc_content <- lapply(path_to_files, rcc.read)
counts <- lapply(rcc_content, extract_counts)
names(counts) <- accession
counts <- do.call(cbind,counts)
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
exc_probes <- probe.exclusion(control_genes)
if(housekeep == "predict"){
temp_facs <- factor_calculation(rcc_content,housekeep,norm, exc_probes)
rownames(temp_facs) <- accession
tmp_counts <- lapply(colnames(counts), function(x) {
local <- counts[,x] - temp_facs[x,"Negative_factor"]
local <- counts[,x] * temp_facs[x,"Positive_factor"]
local[local <= 0] <- 0.1
local <- round(local)
local
})
names(tmp_counts) <- accession
tmp_counts<- do.call(cbind,tmp_counts)
predicted_housekeeping <<- predict.housekeeping(tmp_counts)
housekeep <- paste(predicted_housekeeping,collapse = "@")
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
}
qc_values <- lapply(rcc_content, qc_features)
qc_values <- do.call(rbind, qc_values)
qc_values <- as.data.frame(qc_values, stringsAsFactors=F)
norm_factor <- factor_calculation(rcc_content,housekeep,norm, exc_probes)
rownames(norm_factor) <- accession
pcas <- prinicipal_components(counts)
rownames(qc_values) <- accession
rownames(ssheet_df) <- accession
summar <- list("features" = qc_values,
"ssheet" = ssheet_df,
"pc" = pcas[[1]],
"pcsum" = pcas[[2]],
"norm_facs" = norm_factor,
"control" = control_genes,
"counts" = counts,
"path" = data_dir,
"access" = id_colname,
"locations" = location_match,
"housekeep" = housekeep)
return(summar)
}
#' @title Normalize
#' @description Calculates sample specific size factors and normalizes
#' nanoString nCounter RCC files.
#' @param summary Summary of analyzed nanoString nCounter RCC files.
#' @param housekeep Vector with the names of the housekeeping genes. When no input is given,
#' the default housekeeping genes are used.
#' @param remove.outliers Logical indicator if outliers ought to be removed before size factor
#' calculation and normalization. If outliers are not removed, the the calculated size factors
#' from summarize will be used.
#' @param norm A string indicating which form of calculation needs to be performed:
#' "GEO" or "GLM"
#' @return A list containing the raw counts as data frame, normalized counts as data frame and
#' normalization factors as dataframe.
#' @examples
#' normalize(my.summary,predicted_housekeeping,T,"GLM)
#' normalize(my.summary,c("hsa-miR-361-5p","hsa-miR-186-5p","hsa-miR-26a-5p"),F,"GEO")
#' @export
normalize <- function(summary, housekeep="", remove.outliers=T, norm="GEO"){
if(remove.outliers){
housekeep <- paste(housekeep,collapse = "@")
ssheet_df <- remove.outliers(summary)
accession <- ssheet_df[,summary[["access"]]]
path <- summary[["path"]]
location_match <- summary[["locations"]]
path_to_files <- paste(path,location_match[accession],sep="/")
rcc_content <- lapply(path_to_files, rcc.read)
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
exc_probes <- probe.exclusion(control_genes)
norm_factor <- factor_calculation(rcc_content, housekeep = housekeep, norm, exc_probes)
rownames(norm_factor) <- accession
counts <- lapply(rcc_content, extract_counts)
counts <- do.call(cbind,counts)
colnames(counts) <- accession
raw_counts <- counts
}else{
norm_factor <- summary[["norm_facs"]]
counts <- summary[["counts"]]
}
counts <- sapply(colnames(counts), function(x) {
local <- counts[,x] - norm_factor[x,"Negative_factor"]
local
})
counts <- lapply(colnames(counts), function(x){
local <- counts[,x] * norm_factor[x,"Positive_factor"] * norm_factor[x,"House_factor"]
local[local <= 0] <- 0.1
local <- round(local)
local
})
names(counts) <- accession
counts <-do.call(cbind.data.frame, counts)
output <- list("counts" = raw_counts,
"scaling" = norm_factor,
"normalized" = counts)
return(output)
}
#' @title Visualize
#' @description Visualizes the summarized nanoString nCounter RCC files in a
#' Shiny dashboard
#' @param summary Summary of analyzed nanoString nCounter RCC files.
#' @export
#' @import shiny
#' @import DT
#' @import ggplot2
#' @import ggbeeswarm
#' @import gtools
#' @import reshape2
visualize <- function(summary=NULL){
require(shiny)
require(DT)
require(ggplot2)
require(ggbeeswarm)
require(gtools)
require(reshape2)
require(Biobase)
if(is.null(summary)){
stop("No data provided.")
}
if(T %in% is.na(match(names(summary), c("features",
"ssheet",
"pc",
"pcsum",
"norm_facs",
"control",
"counts",
"path",
"access","locations","housekeep")))){
stop("No valid data provided. \n Use summarize() to generate data")
}
dir <- "./dashboard"
#dir <- system.file("shiny-examples", "nacho_app", package = "testnacho")
qcdata_ssheet <<- summary
runApp(dir)
return(getwd())
}
summarize("C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970",
"C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970/Samplesheet",
"geo_accession",housekeep = "predict",norm = "GLM")
summarize("C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970",
"C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970/Samplesheet.csv",
"geo_accession",housekeep = "predict",norm = "GLM")
exampleData <-summarize("C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970",
"C:/Users/gbouland/Desktop/Git_projects/nanoString_QC2.0/data/GSE70970/Samplesheet.csv",
"geo_accession",housekeep = "predict",norm = "GLM")
visualize(exampleData)
devtools::use_data(exampleData,exampleData)
roxygen2::roxygenise()
visualize <- function(summary=NULL){
require(shiny)
require(DT)
require(ggplot2)
require(ggbeeswarm)
require(gtools)
require(reshape2)
require(Biobase)
if(is.null(summary)){
stop("No data provided.")
}
if(T %in% is.na(match(names(summary), c("features",
"ssheet",
"pc",
"pcsum",
"norm_facs",
"control",
"counts",
"path",
"access","locations","housekeep")))){
stop("No valid data provided. \n Use summarize() to generate data")
}
#dir <- "./dashboard"
dir <- system.file("shiny", "dashboard", package = "nacho")
qcdata_ssheet <<- summary
runApp(dir)
return(getwd())
}
devtools::build()
visualize <- function(summary=NULL){
require(shiny)
require(DT)
require(ggplot2)
require(ggbeeswarm)
require(gtools)
require(reshape2)
require(Biobase)
if(is.null(summary)){
stop("No data provided.")
}
if(T %in% is.na(match(names(summary), c("features",
"ssheet",
"pc",
"pcsum",
"norm_facs",
"control",
"counts",
"path",
"access","locations","housekeep")))){
stop("No valid data provided. \n Use summarize() to generate data")
}
#dir <- "./dashboard"
dir <- system.file("shiny", "dashboard", package = "nacho")
qcdata_ssheet <<- summary
runApp(dir)
return(getwd())
}
devtools::build()
normalize <- function(summary, housekeep="", remove.outliers=T, norm="GEO"){
if(remove.outliers){
housekeep <- paste(housekeep,collapse = "@")
ssheet_df <- remove.outliers(summary)
accession <- ssheet_df[,summary[["access"]]]
path <- summary[["path"]]
location_match <- summary[["locations"]]
path_to_files <- paste(path,location_match[accession],sep="/")
print(path_to_files)
rcc_content <- lapply(path_to_files, rcc.read)
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
exc_probes <- probe.exclusion(control_genes)
norm_factor <- factor_calculation(rcc_content, housekeep = housekeep, norm, exc_probes)
rownames(norm_factor) <- accession
counts <- lapply(rcc_content, extract_counts)
counts <- do.call(cbind,counts)
colnames(counts) <- accession
raw_counts <- counts
}else{
norm_factor <- summary[["norm_facs"]]
counts <- summary[["counts"]]
}
counts <- sapply(colnames(counts), function(x) {
local <- counts[,x] - norm_factor[x,"Negative_factor"]
local
})
counts <- lapply(colnames(counts), function(x){
local <- counts[,x] * norm_factor[x,"Positive_factor"] * norm_factor[x,"House_factor"]
local[local <= 0] <- 0.1
local <- round(local)
local
})
names(counts) <- accession
counts <-do.call(cbind.data.frame, counts)
output <- list("counts" = raw_counts,
"scaling" = norm_factor,
"normalized" = counts)
return(output)
}
devtools::build()
devtools::build()
devtools::build()
devtools::build()
remove.outliers <- function(summarized){
id_colname <- summarized[["access"]]
qc <- summarized$features
ssheet <- summarized$ssheet
factors <- summarized$norm_facs
binding_out <- rownames(qc[as.numeric(qc$BD) > 2.25 |
as.numeric(qc$BD) < 0.1,])
fov_out <- rownames(qc[as.numeric(qc$FoV) < 75,])
pc_out <- rownames(qc[as.numeric(qc$PC) < 0.95,])
lod_out <- rownames(qc[as.numeric(qc$LoD) < 2,])
fac_out <- rownames(factors[factors$Positive_factor < (1/4) |
factors$Positive_factor > 4,])
house_out <- rownames(factors[factors$House_factor < (1/11) |
factors$House_factor >11,])
all_out <- unique(c(binding_out,fov_out,pc_out,lod_out, house_out, fac_out))
outliers_removed <- ssheet[!ssheet[,id_colname] %in% all_out,]
return(outliers_removed)
}
devtools::build()
devtools::build()
