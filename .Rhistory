}
path_to_files <- paste(data_dir,location_match[accession],sep="/")
rcc_content <- lapply(path_to_files, rcc.read)
counts <- lapply(rcc_content, extract_counts)
names(counts) <- accession
counts <- do.call(cbind,counts)
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
exc_probes <- probe.exclusion(control_genes)
if(housekeep == "predict"){
temp_facs <- factor_calculation(rcc_content,housekeep,norm, exc_probes)
rownames(temp_facs) <- accession
tmp_counts <- lapply(colnames(counts), function(x) {
local <- counts[,x] - temp_facs[x,"Negative_factor"]
local <- counts[,x] * temp_facs[x,"Positive_factor"]
local[local <= 0] <- 0.1
local <- round(local)
local
})
names(tmp_counts) <- accession
tmp_counts<- do.call(cbind,tmp_counts)
predicted_housekeeping <<- predict.housekeeping(tmp_counts)
housekeep <- paste(predicted_housekeeping,collapse = "@")
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
}
qc_values <- lapply(rcc_content, qc_features)
qc_values <- do.call(rbind, qc_values)
qc_values <- as.data.frame(qc_values, stringsAsFactors=F)
norm_factor <- factor_calculation(rcc_content,housekeep,norm, exc_probes)
rownames(norm_factor) <- accession
pcas <- prinicipal_components(counts)
rownames(qc_values) <- accession
rownames(ssheet_df) <- accession
summar <- list("features" = qc_values,
"ssheet" = ssheet_df,
"pc" = pcas[[1]],
"pcsum" = pcas[[2]],
"norm_facs" = norm_factor,
"control" = control_genes,
"counts" = counts,
"path" = data_dir,
"access" = id_colname,
"locations" = location_match,
"housekeep" = housekeep)
return(summar)
}
#' @title Normalize
#' @description Calculates sample specific size factors and normalizes
#' nanoString nCounter RCC files.
#' @param summary Summary of analyzed nanoString nCounter RCC files.
#' @param housekeep Vector with the names of the housekeeping genes. When no input is given,
#' the default housekeeping genes are used.
#' @param remove.outliers Logical indicator if outliers ought to be removed before size factor
#' calculation and normalization. If outliers are not removed, the the calculated size factors
#' from summarize will be used.
#' @param norm A string indicating which form of calculation needs to be performed:
#' "GEO" or "GLM"
#' @return A list containing the raw counts as data frame, normalized counts as data frame and
#' normalization factors as dataframe.
#' @examples
#' normalize(my.summary,predicted_housekeeping,T,"GLM)
#' normalize(my.summary,c("hsa-miR-361-5p","hsa-miR-186-5p","hsa-miR-26a-5p"),F,"GEO")
#' @export
normalize <- function(summary, housekeep="", remove.outliers=T, norm="GEO"){
if(remove.outliers){
housekeep <- paste(housekeep,collapse = "@")
ssheet_df <- remove.outliers(summary)
accession <- ssheet_df[,summary[["access"]]]
path <- summary[["path"]]
location_match <- summary[["locations"]]
path_to_files <- paste(path,location_match[accession],sep="/")
rcc_content <- lapply(path_to_files, rcc.read)
control_genes <- lapply(rcc_content, control_genes, housekeep)
names(control_genes) <- accession
control_genes <- melt(control_genes,
id.vars=c("CodeClass","Name","Accession","Count"))
exc_probes <- probe.exclusion(control_genes)
norm_factor <- factor_calculation(rcc_content, housekeep = housekeep, norm, exc_probes)
rownames(norm_factor) <- accession
counts <- lapply(rcc_content, extract_counts)
counts <- do.call(cbind,counts)
colnames(counts) <- accession
raw_counts <- counts
}else{
norm_factor <- summary[["norm_facs"]]
counts <- summary[["counts"]]
}
counts <- sapply(colnames(counts), function(x) {
local <- counts[,x] - norm_factor[x,"Negative_factor"]
local
})
counts <- lapply(colnames(counts), function(x){
local <- counts[,x] * norm_factor[x,"Positive_factor"] * norm_factor[x,"House_factor"]
local[local <= 0] <- 0.1
local <- round(local)
local
})
names(counts) <- accession
counts <-do.call(cbind.data.frame, counts)
output <- list("counts" = raw_counts,
"scaling" = norm_factor,
"normalized" = counts)
return(output)
}
#' @title Visualize
#' @description Visualizes the summarized nanoString nCounter RCC files in a
#' Shiny dashboard
#' @param summary Summary of analyzed nanoString nCounter RCC files.
#' @export
#' @import shiny
#' @import DT
#' @import ggplot2
#' @import ggbeeswarm
#' @import gtools
#' @import reshape2
visualize <- function(summary=NULL){
require(shiny)
require(DT)
require(ggplot2)
require(ggbeeswarm)
require(gtools)
require(reshape2)
require(Biobase)
if(is.null(summary)){
stop("No data provided.")
}
if(T %in% is.na(match(names(summary), c("features",
"ssheet",
"pc",
"pcsum",
"norm_facs",
"control",
"counts",
"path",
"access","locations","housekeep")))){
stop("No valid data provided. \n Use summarize() to generate data")
}
dir <- "./dashboard"
#dir <- system.file("shiny-examples", "nacho_app", package = "testnacho")
qcdata_ssheet <<- summary
runApp(dir)
return(getwd())
}
#' @title Imaging QC
#' @description Calculates percentage succesfully counted image sections.
#' @param fov.counted succesfully counted image sections.
#' @param fov.count attempted counted image sections.
#' @return Percentage succesfully counted image sections.
#' @keywords internal
imaging.qc <- function(fov.counted, fov.count){
fov = (fov.counted / fov.count) * 100
return(round(fov,2))
}
#' @title Positive Control Linearity QC
#' @description  Calculates pearsons correlation coefficient of
#' positive control gene expression versus concentrations.
#' @param pos.counts Vector of measured positive control gene expression.
#' @return Correlation coefficient
#' @keywords internal
positive.control.qc <- function(pos.counts){
known <- log2(c(128,32,8,2,0.5))
measured <- log2(pos.counts[1:5])
correlation <- cor.test(known, measured)
return(unname(round(correlation$estimate,5)))
}
#' @title Limit of Detection QC
#' @description Calculates distance of POS_E expression from mean of
#'  negative control gene expressoins in term of standard deviations.
#' @param pos.e Expression of positive control gene "POS_E"
#' @param negatives Vector of negative control gene expressoins.
#' @return z-score
#' @keywords internal
limit.detection.qc <- function(pos.e, negatives){
z_score <- pos.e - mean(negatives) / sd(negatives)
return(round(z_score,2))
}
#' @title Prinicipal components
#' @description Calculates and returns principal components of a given
#' dataframe.
#' @param counts dataframe of nanoString counts
#' @return list containing a dataframe the first 10 principal components
#' and summary
#' @keywords internal
prinicipal_components <- function(counts){
pc <- prcomp(log(counts+1))
pc_sum <- summary(pc)
pc <- pc$rotation[,1:10]
output <- list("pc" = pc,
"pcsum" = pc_sum$importance[,1:10])
return(output)
}
#' @title Geometric mean
#' @description Calculates and returns geometric mean of a given vector.
#' @param vector_data numeric vector
#' @return geometric mean
#' @keywords internal
geoMean <- function(vector_data){
vector_data[vector_data == 0] <- 1
exp(mean(log(vector_data)))
}
#' @title Extracts counts of control probes and calculates the geometric mean.
#' @description Extracts counts of control probes and calculates the
#' geometric mean. Excludes positive control probe F in calculation.
#' @param rcc_content List of dataframes originating from RCC files
#' @param probes String of either "Positve" or "Negative"
#' @return geometric mean of control probes
#' @keywords internal
geometric <- function(rcc_content, probes,ex_negs=NULL){
counts <- rcc_content$Code_Summary
if(probes == "Positive"){
control_data <- as.numeric(counts[counts$CodeClass %in%
probes & counts$Name !=
"POS_F(0.125)","Count"])
control_data[control_data == 0] <- 1
}else if(probes == "Negative"){
probes_out <- ex_negs
control_data <- counts[!counts$Name %in% probes_out,]
control_data <- as.numeric(counts[counts$CodeClass %in%
probes,"Count"])
control_data[control_data == 0] <- 1
}
return(geoMean(control_data))
}
#' @title Calculates the background threshold and positive normalization
#' factor by means of generalized linear models.
#' @description Calculates the background threshold and positive normalization
#' factor by means of generalized linear models. Uses the intercept of the model
#' as background threshold and the slope as positive normalization factor,
#' excludes positive control probe F.
#' @param rcc_content List of dataframes originating from RCC files
#' @return Vector with positive factor and backrground threshold
#' @keywords internal
intercept_slope <- function(rcc_content,exc_negs){
probes_out <- c("POS_F(0.125)",exc_negs)
counts <- rcc_content$Code_Summary
control_labels <- c("Positive","Negative")
control_data <- counts[counts$CodeClass %in% control_labels,]
control_data <- control_data[order(control_data$Name),]
control_data <- control_data[!control_data$Name %in% probes_out,]
prob_names <- paste0(control_data$Name,collapse = "")
y <- as.numeric(control_data$Count) + 1
x <- as.numeric(gsub("[\\(\\)]", "", regmatches(prob_names,
gregexpr("\\(.*?\\)", prob_names))[[1]]))
model <- glm(y~x, family = poisson(link = identity))
output <- c("intercept" = unname(model$coeff[1]),
"slope" = unname(model$coeff[2]))
return(output)
}
#' @title Factor Calculation
#' @description Calculates normalization factors
#' @param rcc_content List of dataframes originating from RCC files
#' @param housekeep String of names of housekeeping genes
#' @param norm A string indicating which form of calculation needs to be performed
#' @return Dataframe of normalization factor for each sample
#' @keywords internal
factor_calculation <- function(rcc_content, housekeep, norm, ex_negs){
if(norm == "GEO"){
geometric_mean_pos <- sapply(rcc_content, geometric, "Positive")
geometric_mean_neg <- sapply(rcc_content, geometric, "Negative",ex_negs)
positive_factor <- sapply(geometric_mean_pos,
function(x) mean(geometric_mean_pos) / x)
}else if(norm == "GLM"){
glms <- sapply(rcc_content, intercept_slope, ex_negs)
geometric_mean_neg <- glms["intercept",]
slopes <- glms["slope",]
positive_factor <- sapply(slopes,
function(x) mean(slopes) / x)
}
if(housekeep == "predict"){
norm_factor <- data.frame("Positive_factor" = positive_factor,
"Negative_factor" = geometric_mean_neg)
}else{
housecounts <- mapply(housekeeping,rcc_content, positive_factor,
geometric_mean_neg, housekeep)
housecounts <- as.data.frame(housecounts)
geometric_mean_house <- sapply(housecounts,
function(x) geoMean(x))
house_factor <- sapply(geometric_mean_house,
function(x) mean(geometric_mean_house) / x)
house_factor <- unname(house_factor)
norm_factor <- data.frame("Positive_factor" = positive_factor,
"Negative_factor" = geometric_mean_neg,
"House_factor" = house_factor)
}
return(norm_factor)
}
#' @title Predict housekeeping genes
#' @description Predicts which genes could serve as housekeeping genes
#' @param counts dataframe of nanoString counts
#' @return vector of 5 possible housekeeping genes
#' @keywords internal
predict.housekeeping <- function(counts){
sample_means <- sapply(colnames(counts), function(x) mean(counts[,x]))
ratios <- sapply(colnames(counts), function(x) log2(counts[,x] / sample_means[x]))
ratios <- ratios[sum(is.infinite(ratios)) / length(ratios) <= 0.05,]
ratios <- ifelse(is.infinite(ratios),NA,ratios)
miR_sd <- sapply(rownames(ratios), function(x) sd(ratios[x,],na.rm = TRUE))
miR_sd <- sort(miR_sd, decreasing = F)
return(names(miR_sd)[1:5])
}
#' @title Probe exclusion
#' @description Compares probe specfic median with overal median, excludes probes when
#' probe specific mean differs more than 50% from overal median
#' @param control_genes dataframe of all control genes
#' @return names of excluded probes
#' @keywords internal
probe.exclusion <- function(control_genes){
local_neg <- control_genes[control_genes$CodeClass == "Negative",]
dcasted<- dcast(L1~Name, data = local_neg[,c("Name","L1","Count")], value.var = "Count")
rownames(dcasted) <- dcasted$L1
dcasted$L1 <- NULL
overal_median <- median(as.numeric(local_neg$Count))
medians <- sapply(dcasted,function(x) median(as.numeric(x)))
delta_medians <- sapply(medians,function(x) abs((overal_median-x)))
ex_probes <- delta_medians[delta_medians > (0.5*overal_median)]
return(names(ex_probes))
}
#' @title Read RCC files
#' @description Reads RCC or RCC.gz files.
#' @param rcc.file File extension of nanoString with predefined XML-like tags
#' @return List of dataframes containing the data between the predefined
#'  XML-like tags.
#'@keywords internal
rcc.read <- function(rcc.file){
tags <- c("Header","Sample_Attributes",
"Lane_Attributes","Code_Summary","Messages")
raw <- readLines(rcc.file)
raw <- sapply(raw,function(x) gsub("[|]+[[:digit:]]+\\.*[[:digit:]]*","",x))
tag.positions <- sapply(tags, function(y) grep(y,raw))
rcc.list <- apply(tag.positions,2,extract_data,raw)
colnames(rcc.list$Code_Summary) <- rcc.list$Code_Summary[1,]
rcc.list$Code_Summary <- rcc.list$Code_Summary[-1,]
tmp<- sapply(tags[-4],change_rows ,rcc.list)
rcc.list[names(tmp)] <- tmp
return(rcc.list)
}
#' @title Extracts data between XML-like RCC tags
#' @description Extracts data between XML-like RCC tags and saves
#'  them as data.frame.
#' @param positions Vector containing "<tag>" and "</tag>" location
#'  in raw RCC file.
#' @param raw_rcc Raw RCC file.
#' @return Data.frame containing the data between the XML-like tags.
#' @keywords internal
extract_data <- function(positions, raw_rcc){
content.list <- raw_rcc[(positions[1]+ 1):(positions[2]-1)]
td.content.list <- lapply(content.list,
function(vec) unique(unlist(strsplit(vec, ","))))
content.df <- as.data.frame(do.call(rbind,td.content.list),
stringsAsFactors = F)
return(content.df)
}
#' @title Changes first row into column names
#' @description Changes the first row of a selection of dataframes
#'  from a list to column names.
#' @param attribute Name of element in list in which the first row
#'  needs to change to column names.
#' @param list List containing dataframes.
#' @return Changed element with first row as column name.
#' @keywords internal
change_rows <- function(attribute, list){
rownames(list[[attribute]]) <- list[[attribute]][,1]
list[[attribute]][,1] <- NULL
return(list[[attribute]])
}
#' @title Loads Samplesheet.csv
#' @param ssheet path to Samplesheet.csv
#' @return Samplesheet.csv as data.frame
#' @keywords internal
load.samplesheet <- function(ssheet){
ssheet_df <- read.csv(ssheet, header = T, sep=",")
return(ssheet_df)
}
#' @title Extracts counts
#' @description Extracts Endogenous counts from the Code_Summary dataframe
#' originating from the RCC files
#' @param rcc_content List of dataframes originating from RCC files
#' @return Vector of Endogenous counts of specified RCC file
#' @keywords internal
extract_counts <- function(rcc_content){
counts <- rcc_content$Code_Summary
spec_counts <- as.numeric(counts[grep("Endogenous",
counts$CodeClass),"Count"])
names(spec_counts) <- counts[grep("Endogenous",
counts$CodeClass),"Name"]
return(spec_counts)
}
#' @title Calculates all QC values
#' @description  Calculates all consecutive QC values by calling QC calculation
#'functions and processes these values into a vector.
#' @param rcc_content List of dataframes originating from RCC files
#' @return Vector of QC values.
#' @keywords internal
qc_features <- function(rcc_content){
sample <- rcc_content$Sample_Attributes
lane <- rcc_content$Lane_Attributes
counts <- rcc_content$Code_Summary
sample_labels <- c("Date")
lane_labels <- c("ID","FovCounted","FovCount","BindingDensity",
"ScannerID","StagePosition","CartridgeID")
control_labels <- c("Positive","Negative")
sample_data <- sapply(sample_labels,function(y) sample[y,])
lane_data <- sapply(lane_labels,function(y) lane[y,])
control_data <- counts[counts$CodeClass %in% control_labels,]
control_data <- control_data[order(control_data$Name),]
positives <- as.numeric(control_data[control_data$CodeClass %in%
"Positive","Count"])
negatives <- as.numeric(control_data[control_data$CodeClass %in%
"Negative","Count"])
counts <- as.numeric(counts[grep("Endogenous",counts$CodeClass),
"Count"])
pc <- positive.control.qc(positives)
ld <- limit.detection.qc(pos.e = positives[5]
, negatives = negatives)
fov <- imaging.qc(fov.counted = as.numeric(lane_data["FovCounted"]),
fov.count = as.numeric(lane_data["FovCount"]))
mean_count <- round(mean(counts),2)
median_count <- median(counts)
output <- c(sample_data["Date"],lane_data["ID"],
"BD" = unname(lane_data["BindingDensity"]),
lane_data["ScannerID"],lane_data["StagePosition"],
lane_data["CartridgeID"],"FoV" = fov,"PC" = pc,
"LoD" = ld,"MC" = mean_count,"MedC" = median_count)
return(output)
}
#' @title Removing of outliers
#' @description  Detects outliers based on QC measures and normalization
#' factors all thresholds are as mentioned by the manufacturer.
#' @param rcc_content List of dataframes originating from RCC files
#' @return Subset of the original Samplesheet provided by the user
#' @keywords internal
remove.outliers <- function(summarized){
id_colname <- summarized[["access"]]
qc <- summarized$features
ssheet <- summarized$ssheet
factors <- summarized$norm_facs
binding_out <- rownames(qc[as.numeric(qc$BD) > 2.25 |
as.numeric(qc$BD) < 0.1,])
fov_out <- rownames(qc[as.numeric(qc$FoV) < 75,])
pc_out <- rownames(qc[as.numeric(qc$PC) < 0.95,])
lod_out <- rownames(qc[as.numeric(qc$LoD) < 2,])
fac_out <- rownames(factors[factors$Positive_factor < (1/4) |
factors$Positive_factor > 4,])
house_out <- rownames(factors[factors$House_factor < (1/11) |
factors$House_factor >11,])
all_out <- unique(c(binding_out,fov_out,pc_out,lod_out, house_out, fac_out))
outliers_removed <- ssheet[!ssheet[,id_colname] %in% all_out,]
return(outliers_removed)
}
#' @title Extracts all counts other than the Endogenous ones.
#' @description  Extracts all counts which are not named: Endogenous.
#' if the user has given custom houskeeping genes, these will also be
#' extracted and treated as control genes.
#' @param rcc_content List of dataframes originating from RCC files
#' @param custom String of concatenated housekeeping genes.
#' @return Vector of counts other than Endogenous.
#' @keywords internal
control_genes <- function(rcc_content, custom){
counts <- rcc_content$Code_Summary
if(custom != ""){
custom <- unlist(strsplit(custom,"@"))
house <- counts[counts$Name %in% custom,]
counts <- counts[!grepl("Endogenous",counts$CodeClass),]
counts <- rbind(counts,house)
}else{
counts <- counts[!grepl("Endogenous",counts$CodeClass),]
}
return(counts)
}
#' @title Extract housekeeping genes and performs initial normalization
#' transformation on housekeeping counts
#' @description Extract housekeeping genes and performs initial normalization
#' transformation, so that housekeeping normaliztion factors can be calulated
#' independent of technical variation.
#' @param rcc_content List of dataframes originating from RCC files
#' @param pos_fact Positive normalization factor
#' @param intercept background threshold
#' @param custom String of concatenated housekeeping genes.
#' @return Vector transformed housekeeping gene counts.
#' @keywords internal
housekeeping <- function(rcc_content, pos_fact, intercept, custom){
counts <- rcc_content$Code_Summary
if(custom == ""){
house <- as.numeric(counts[counts$CodeClass %in%
"Housekeeping","Count"])
name <- counts[counts$CodeClass %in%
"Housekeeping","Name"]
}else{
custom <- unlist(strsplit(custom,"@"))
custom <- unlist(lapply(custom, function(x) unlist(strsplit(x,"\\|"))[1]))
house <- sapply(custom, function(x) as.numeric(counts[grepl(x, counts$Name),"Count"]))
}
house <- house - intercept
house <- house * pos_fact
house[house <= 0] <- 1
return(house)
}
test <- summarize("C:/Users/gbouland/Desktop/Data_test",
"Z:/Roderick/Projects/Rhapsody/004 Omics/003 QC_Nanostring_miRNA/Samplesheet.csv",
"Accession","predict","GLM")
test <- summarize("Z:/Roderick/Projects/Rhapsody/004 Omics/003 QC_Nanostring_miRNA",
"Z:/Roderick/Projects/Rhapsody/004 Omics/003 QC_Nanostring_miRNA/ssheet_dr.csv",
"Accession","predict","GLM")
test <- summarize("Z:/Roderick/Projects/Rhapsody/004 Omics/003 QC_Nanostring_miRNA/999 Data",
"Z:/Roderick/Projects/Rhapsody/004 Omics/003 QC_Nanostring_miRNA/004 Samplesheets/ssheet_dr.csv",
"Accession","predict","GLM")
visualize(test)
